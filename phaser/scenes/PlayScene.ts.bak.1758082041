// phaser/scenes/PlayScene.ts
import * as Phaser from 'phaser';
import Bullet from '../entities/Bullet';
import Enemy from '../entities/Enemy';
import FormationManager from '../systems/FormationManager';

type AllyEntry = {
  sprite: Phaser.Types.Physics.Arcade.SpriteWithDynamicBody;
  offset: Phaser.Math.Vector2;
  behavior: string;
  orbitBaseAngle?: number;
  orbitRadius?: number;
};

export class PlayScene extends Phaser.Scene {
  private bg!: Phaser.GameObjects.TileSprite;
  private player!: Phaser.Types.Physics.Arcade.SpriteWithDynamicBody;
  private cursors!: Phaser.Types.Input.Keyboard.CursorKeys;

  private bullets!: Phaser.Physics.Arcade.Group;
  private enemies!: Phaser.Physics.Arcade.Group;
  private enemyBullets!: Phaser.Physics.Arcade.Group;

  private fireCooldown = 0;
  private formationKey!: Phaser.Input.Keyboard.Key;
  private explosionEmitter?: Phaser.GameObjects.Particles.ParticleEmitter;

  // Enemy formations (HUD)
  private formationManager?: FormationManager;

  // Player formations
  private playerFormations: any[] = [];
  private currentPlayerFormationIdx = 0;

  // Allies
  private allies: AllyEntry[] = [];

  // Player HP / HUD
  private playerMaxHp = 10;
  private playerHp = 10;
  private isInvulnerable = false;
  private invulTween?: Phaser.Tweens.Tween;
  private invulTimer?: Phaser.Time.TimerEvent;
  private hpBarGraphics!: Phaser.GameObjects.Graphics;
  private hpText!: Phaser.GameObjects.Text;

  constructor() {
    super('play');
  }

  preload() {
    // sprites / atlas
    this.load.image('bg', '/sprites/bg.png');
    this.load.image('player', '/sprites/player.png');
    this.load.image('enemy', '/sprites/enemy.png');
    this.load.image('bullet', '/sprites/bullet.png');
    this.load.atlas('flares', '/sprites/flares.png', '/sprites/flares.json');

    // formation files
    this.load.json('formation_index', '/formations/index.json');
    this.load.json('player_formations', '/formations/insects.json');
  }

  create() {
    console.log('[PlayScene] create');
    const { width, height } = this.scale;

    // background
    this.add.rectangle(0, 0, width, height, 0x061025).setOrigin(0, 0);
    this.bg = this.add.tileSprite(0, 0, width, height, 'bg').setOrigin(0, 0);

    // hint
    this.add.text(12, 14, 'Arrows = move • Space = fire • F = cycle player formations', { color: '#9fb0c7' });

    // player
    this.player = this.physics.add.sprite(width * 0.5, height * 0.8, 'player');
    this.player.setDisplaySize(48, 48);
    this.player.setCollideWorldBounds(true);
    this.player.setCircle(18);

    // groups
    this.bullets = this.physics.add.group({ classType: Bullet, maxSize: 300 });
    this.enemies = this.physics.add.group({ classType: Enemy, maxSize: -1 });
    this.enemyBullets = this.physics.add.group({ classType: Bullet, maxSize: 400 });

    // input
    this.cursors = this.input.keyboard.createCursorKeys();
    this.formationKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);

    // particles (explosions)
    this.explosionEmitter = this.add.particles(0, 0, 'flares', {
      frame: 'red',
      lifespan: 450,
      speed: { min: 100, max: 220 },
    });

    // collisions: bullets -> enemies
    this.physics.add.overlap(this.bullets, this.enemies, (bObj, eObj) => {
      const b = bObj as Bullet;
      const e = eObj as Enemy;
      if (!b || !e) return;

  // Debug: shows owner/damage/active flags (remove or lower verbosity after debugging)
      console.debug('[COLLISION] bullet->enemy', {
        owner: (b as any).owner,
        damage: (b as any).damage,
        bActive: b.active,
        eActive: e.active,
      });

  if (!b.active || !e.active) return;

  // enemy bullets should not damage enemies
      if ((b as any).owner === 'enemy') return;

  // reliably remove bullet from world (return to pool)
        b.kill ? b.kill() : b.disableBody(true, true);

        const dmg = (b as any).damage ?? 1;
        const killed = typeof e.receiveDamage === 'function' ? e.receiveDamage(dmg) : false;
        if (killed && this.explosionEmitter) this.explosionEmitter.explode(10, e.x, e.y);
    });


    // collisions: player -> enemy (physical contact)
    this.physics.add.overlap(this.player, this.enemies, (_p, eObj) => {
      const e = eObj as Enemy;
      // damage amount from enemy or default 1
      const dmg = Math.max(1, e.hp ?? 1);
      this.damagePlayer(dmg);
    });

    // collisions: player -> enemy bullets
    this.physics.add.overlap(this.player, this.enemyBullets, (_p, bObj) => {
      const b = bObj as Bullet;
      if (!b.active) return;
      const dmg = (b as any).damage ?? 1;
      b.kill ? b.kill() : b.disableBody(true, true);
      this.damagePlayer(dmg);
    });

    // FormationManager for enemy waves
    this.formationManager = new FormationManager(this, this.enemies, this.enemyBullets);

    // load player formations
    const pf = this.cache.json.get('player_formations');
    this.playerFormations = Array.isArray(pf?.formations) ? pf.formations : [];
    console.log('[PlayScene] playerFormations:', this.playerFormations.map((f:any)=>f.id));

    // HUD → enemy waves
    this.game.events.on('formation:selected', (filename?: string) => {
      if (filename && this.formationManager) {
        console.log('[PlayScene] HUD selected enemy formation:', filename);
        this.formationManager.loadAndScheduleFromFile(filename).catch((e) => console.warn(e));
      }
    });

    // auto-load first enemy wave (optional)
    const idx = this.cache.json.get('formation_index');
    const files = Array.isArray(idx?.files) ? idx.files : [];
    if (files.length > 0) {
      this.formationManager.loadAndScheduleFromFile(files[0]).catch((e) => console.warn(e));
    }

    // HP HUD: graphics + numeric text
    this.createHpHud();

    // initialize HP values
    this.playerMaxHp = 10;
    this.playerHp = this.playerMaxHp;
    this.updateHpHud();

    // allies empty initially
    this.allies = [];
  }

  update(_time: number, delta: number) {
    const dt = delta / 1000;
    this.bg.tilePositionY -= 60 * dt;

    // movement
    const speed = 280;
    const vx = (this.cursors.left?.isDown ? -1 : 0) + (this.cursors.right?.isDown ? 1 : 0);
    const vy = (this.cursors.up?.isDown ? -1 : 0) + (this.cursors.down?.isDown ? 1 : 0);
    this.player.setVelocity(vx * speed, vy * speed);

    // firing
    this.fireCooldown -= dt;
    const playerFired = (this.cursors.space?.isDown || this.input.activePointer.isDown) && this.fireCooldown <= 0;
    if (playerFired) {
      this.fireCooldown = 0.15;
      this.fireBullet();
      this.fireAllies();
    }

    // cycle player formations with F
    if (Phaser.Input.Keyboard.JustDown(this.formationKey)) {
      if (this.playerFormations.length > 0) {
        this.currentPlayerFormationIdx = (this.currentPlayerFormationIdx + 1) % this.playerFormations.length;
        const formation = this.playerFormations[this.currentPlayerFormationIdx];
        console.log('[PlayScene] apply player formation:', formation.id);
        this.applyPlayerFormation(formation);
      }
    }

    // update allies following player
    this.updateAllies(dt);

    // cleanup off-screen bullets/enemies
    const h = this.scale.height;
    this.bullets.getChildren().forEach((o) => {
      const b = o as Bullet;
      if (b.active && (b.y < -32 || b.y > h + 32)) b.kill ? b.kill() : b.disableBody(true, true);
    });
    this.enemyBullets.getChildren().forEach((o) => {
      const b = o as Bullet;
      if (b.active && b.y > h + 32) b.kill ? b.kill() : b.disableBody(true, true);
    });
    this.enemies.getChildren().forEach((o) => {
      const e = o as Enemy;
      if ((e as any).active && e.y > h + 80) (e.kill ? e.kill() : (e.disableBody ? e.disableBody(true, true) : null));
    });
  }

  // ---------------- player HP & HUD ----------------

  private createHpHud() {
    // bar: left top area
    this.hpBarGraphics = this.add.graphics().setDepth(1000);
    this.hpText = this.add.text(12, 36, '', { color: '#fff', fontSize: '14px' }).setDepth(1000);
    this.updateHpHud();
  }

  private updateHpHud() {
    // draw bar background + fill according to playerHp / playerMaxHp
    const x = 12, y = 56;
    const w = 180, h = 12;
    const pct = Phaser.Math.Clamp(this.playerHp / this.playerMaxHp, 0, 1);
    this.hpBarGraphics.clear();

    // background box
    this.hpBarGraphics.fillStyle(0x2b2f36, 1);
    this.hpBarGraphics.fillRect(x - 1, y - 1, w + 2, h + 2);

    // fill color (green->yellow->red interpolation)
    const col = Phaser.Display.Color.Interpolate.ColorWithColor(
      new Phaser.Display.Color(255, 0, 0),
      new Phaser.Display.Color(0, 255, 0),
      100,
      Math.round(pct * 100)
    );
    const colorInt = Phaser.Display.Color.GetColor(col.r, col.g, col.b);

    this.hpBarGraphics.fillStyle(colorInt, 1);
    this.hpBarGraphics.fillRect(x, y, Math.max(2, Math.floor(w * pct)), h);

    // numeric
    this.hpText.setText(`HP: ${this.playerHp} / ${this.playerMaxHp}`);
  }

  private damagePlayer(amount: number) {
    if (this.isInvulnerable) {
      console.log('[PlayScene] player is invulnerable, ignoring damage');
      return;
    }

    this.playerHp = Math.max(0, this.playerHp - Math.max(1, Math.floor(amount)));
    console.log('[PlayScene] player damaged:', amount, 'hp->', this.playerHp);
    this.updateHpHud();

    // show brief invulnerability and blink
    this.setPlayerInvulnerable(1000);

    // small flash or explosion
    if (this.explosionEmitter) this.explosionEmitter.explode(6, this.player.x, this.player.y);

    if (this.playerHp <= 0) {
      // death: explosion + go to menu after short delay
      if (this.explosionEmitter) this.explosionEmitter.explode(24, this.player.x, this.player.y);
      this.time.delayedCall(600, () => {
        this.scene.start('menu');
      });
    }
  }

  private setPlayerInvulnerable(ms: number) {
    // clear previous invul state/timers
    if (this.invulTimer) {
      this.invulTimer.remove(false);
      this.invulTimer = undefined;
    }
    if (this.invulTween) {
      this.invulTween.stop();
      this.invulTween = undefined;
    }

    this.isInvulnerable = true;
    // tween alpha to create blinking
    this.invulTween = this.tweens.add({
      targets: this.player,
      alpha: { from: 0.25, to: 1 },
      duration: 150,
      yoyo: true,
      repeat: Math.floor(ms / 150 / 2),
    });

    this.invulTimer = this.time.addEvent({
      delay: ms,
      callback: () => {
        this.isInvulnerable = false;
        if (this.invulTween) {
          this.invulTween.stop();
          this.invulTween = undefined;
        }
        this.player.setAlpha(1);
      },
    });
  }

  // ---------------- bullets / allies / player formation ----------------

  private fireBullet() {
    const b = this.bullets.get(this.player.x, this.player.y - 20, 'bullet') as Bullet;
    if (!b) return;
    b.init(this.player.x, this.player.y - 20, 0, -400, 'bullet', 'player');
  }

  private fireAllies() {
    if (!this.allies.length) return;
    this.allies.forEach((entry) => {
      const s = entry.sprite;
      if (!s?.active) return;
      const b = this.bullets.get(s.x, s.y - 20, 'bullet') as Bullet;
      if (!b) return;
      b.init(s.x, s.y - 20, 0, -400, 'bullet', 'player');
    });
  }

  private applyPlayerFormation(formation: any) {
    // clear existing allies
    this.allies.forEach((a) => {
      try { a.sprite.destroy(); } catch {}
    });
    this.allies = [];

    const w = this.scale.width;
    const h = this.scale.height;
    const boxW = Math.max(120, w * 0.3);
    const boxH = Math.max(80, h * 0.18);

    formation.ships.forEach((ship: any, i: number) => {
      const nx = (ship.x_norm ?? ship.x ?? 50);
      const ny = (ship.y_norm ?? ship.y ?? 50);
      const offsetX = ((nx - 50) / 100) * boxW;
      const offsetY = ((ny - 50) / 100) * boxH;

      const sx = this.player.x + offsetX;
      const sy = this.player.y + offsetY;
      const allySprite = this.physics.add.sprite(sx, sy, 'player');
      allySprite.setDisplaySize(32, 32);
      allySprite.setTint(0x00ffcc);
      allySprite.setData('isAlly', true);

      const entry: AllyEntry = {
        sprite: allySprite,
        offset: new Phaser.Math.Vector2(offsetX, offsetY),
        behavior: formation.behavior ?? 'follow',
      };

      if (entry.behavior === 'orbit') {
        entry.orbitBaseAngle = (i / Math.max(1, formation.ships.length)) * 360;
        entry.orbitRadius = 40 + (i * 8);
      }

      this.allies.push(entry);
    });
  }

  private updateAllies(dt: number) {
    if (!this.allies.length) return;
    const t = this.time.now / 1000;
    const lerpFactor = 0.12;

    this.allies.forEach((entry) => {
      const s = entry.sprite;
      if (!s.active) return;

      let targetX = this.player.x + entry.offset.x;
      let targetY = this.player.y + entry.offset.y;

      if (entry.behavior === 'orbit') {
        const base = entry.orbitBaseAngle ?? 0;
        const radius = entry.orbitRadius ?? 60;
        const speedDeg = 60;
        const ang = Phaser.Math.DegToRad(base + t * speedDeg);
        targetX = this.player.x + Math.cos(ang) * radius;
        targetY = this.player.y + Math.sin(ang) * radius;
      }

      s.x = Phaser.Math.Linear(s.x, targetX, lerpFactor);
      s.y = Phaser.Math.Linear(s.y, targetY, lerpFactor);
    });
  }

  // ---------------- misc ----------------
  private onPlayerHit() {
    // deprecated: we use damagePlayer now
    this.damagePlayer(1);
  }
}

export default PlayScene;
